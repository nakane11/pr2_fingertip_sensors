(load "package://pr2eus/pr2-interface.l")
(ros::roseus-add-msgs "jsk_recognition_msgs")
(ros::roseus-add-msgs "std_msgs")
(ros::roseus-add-msgs "control_msgs")

(unless (boundp '*tfl*)
  (setq *tfl* (instance ros::transform-listener :init)))

(defun wait-for-human ()
  (let ((people-pose-array nil)
        (topic-name "/edgetpu_human_pose_estimator/output/poses_3d")
        (base-link "/base_link") camera-link stamp)
    (ros::subscribe topic-name jsk_recognition_msgs::PeoplePoseArray
                    #'(lambda (msg)
                        (ros::ros-info "sub")
                        (setq people-pose-array (send msg :poses))
                        (setq stamp (send msg :header :stamp))
                        (setq camera-link (send msg :header :frame_id))))
    (block get-coords
      (loop
        (unless (null people-pose-array)
          (dolist (people-pose people-pose-array)
            (let ((joint-poses (send people-pose :poses))
                  (limb-names (send people-pose :limb_names)))
              (dotimes (i (length limb-names))
                (let ((joint (elt joint-poses i))
                      (limb (elt limb-names i)))
                  (when (string-equal limb "nose")
                    (setq nose-coords (ros::tf-pose->coords joint))
                    (setq base2camera (send *tfl* :lookup-transform base-link camera-link stamp))
                    (setq base2nose (send base2camera :transform nose-coords))
                    (setq nose-pos (send base2nose :pos))
                    (ros::ros-info "x: ~A y: ~A" (elt nose-pos 0) (elt nose-pos 1))
                    (when (and (< (elt nose-pos 0) 500) (< (elt nose-pos 1) 150))
                      (return-from get-coords))))))))
        (ros::spin-once)))
    (ros::unsubscribe topic-name)
    ))

(defun l-back-touch ()
  (let ((touch-state nil) result
        (topic-name "/pfs/r_gripper/l_fingertip/pfs_b_right/touch_state"))
    (ros::subscribe topic-name std_msgs::UInt8
                    #'(lambda (msg)
                        (ros::ros-info "sub")
                        (when (eq (send msg :data) 1)
                          (setq touch-state (send msg :data)))))
    (send *pr2* :angle-vector (send *ri* :state :potentio-vector))
    (setq co (send (send (send (send *pr2* :rarm :end-coords) :parent) :parent) :copy-worldcoords))
    (send co :rotate (deg2rad -50) :y :world)
    (send *pr2* :rarm :inverse-kinematics co :rotation-axis :nil :move-target (send (send (send *pr2* :rarm :end-coords) :parent) :parent))
    (setq result nil)
    (send *ri* :angle-vector (send *pr2* :angle-vector) 2500 :rarm-controller)
    (loop
     (when (eq touch-state 1)
       (ros::ros-info "detect touch")
       (send *ri* :cancel-angle-vector :controller-type :rarm-controller)
       (return))
     (setq result (send (cadr (gethash :default-controller (*ri* . controller-table))) :wait-for-result :timeout 0.00001))
     (when result
       (ros::ros-info "get result")
       (return))
     (ros::spin-once))
    (ros::unsubscribe topic-name)))

(defun r-back-touch ()
  (let ((touch-state nil) result
        (topic-name "/pfs/r_gripper/r_fingertip/pfs_b_left/touch_state"))
    (ros::subscribe topic-name std_msgs::UInt8
                    #'(lambda (msg)
                        (ros::ros-info "sub")
                        (when (eq (send msg :data) 1)
                          (setq touch-state (send msg :data)))))
    (send *pr2* :angle-vector (send *ri* :state :potentio-vector))
    (setq co (send (send (send (send *pr2* :rarm :end-coords) :parent) :parent) :copy-worldcoords))
    (send co :rotate (deg2rad 30) :z :world)
    (send *pr2* :rarm :inverse-kinematics co :rotation-axis :nil :move-target (send (send (send *pr2* :rarm :end-coords) :parent) :parent))
    (setq result nil)
    (send *ri* :angle-vector (send *pr2* :angle-vector) 2500 :rarm-controller)
    (loop
     (when (eq touch-state 1)
       (ros::ros-info "detect touch")
       (send *ri* :cancel-angle-vector :controller-type :rarm-controller)
       (return))
     (setq result (send (cadr (gethash :default-controller (*ri* . controller-table))) :wait-for-result :timeout 0.00001))
     (when result
       (ros::ros-info "get result")
       (return))
     (ros::spin-once))
    (ros::unsubscribe topic-name)))

;; (defun stroke-down()
;;   (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector 0 0 -160) :world))
;;   (send *pr2* :rarm :inverse-kinematics target)
;;   (send *ri* :angle-vector (send *pr2* :angle-vector) 3000 :rarm-controller)
;;   (send *ri* :wait-interpolation))

;; (defun stroke-up()
;;   (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector 20 0 40) :world))
;;   (send *pr2* :rarm :inverse-kinematics target)
;;   (setq av1 (send *pr2* :angle-vector))
;;   (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector 20 0 40) :world))
;;   (send *pr2* :rarm :inverse-kinematics target)
;;   (setq av2 (send *pr2* :angle-vector))
;;   (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector -20 0 40) :world))
;;   (send *pr2* :rarm :inverse-kinematics target)
;;   (setq av3 (send *pr2* :angle-vector))
;;   (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector -0 0 40) :world))
;;   (send *pr2* :rarm :inverse-kinematics target)
;;   (setq av4 (send *pr2* :angle-vector))

;;   (send *ri* :angle-vector-sequence (list av1 av2 av3 av4) (list 650 650 650 650))
;;   (send *ri* :wait-interpolation))
(defun stroke-down()
  (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector -160 0 0) :local))
  (send *pr2* :rarm :inverse-kinematics target)
  (send *ri* :angle-vector (send *pr2* :angle-vector) 3000 :rarm-controller)
  (send *ri* :wait-interpolation))

(defun stroke-up()
  (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector 40 0 20) :local))
  (send *pr2* :rarm :inverse-kinematics target)
  (setq av1 (send *pr2* :angle-vector))
  (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector 40 0 20) :local))
  (send *pr2* :rarm :inverse-kinematics target)
  (setq av2 (send *pr2* :angle-vector))
  (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector 40 0 -20) :local))
  (send *pr2* :rarm :inverse-kinematics target)
  (setq av3 (send *pr2* :angle-vector))
  (setq target (send (send *pr2* :rarm :end-coords :copy-worldcoords) :translate (float-vector 40 0 -20) :local))
  (send *pr2* :rarm :inverse-kinematics target)
  (setq av4 (send *pr2* :angle-vector))

  (send *ri* :angle-vector-sequence (list av1 av2 av3 av4) (list 650 650 650 650))
  (send *ri* :wait-interpolation))
